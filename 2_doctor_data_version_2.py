# -*- coding: utf-8 -*-
"""2_DOCTOR DATA  VERSION 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nG4I31WuXGqkGPskJTAB6R4xznL1eRom
"""

!pip install openpyxl -q

# Cell 2: Import Libraries
import pandas as pd
import numpy as np
import re
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter

# Upload your CSV file
from google.colab import files
uploaded = files.upload()

df = pd.read_csv('doctors_data_fixed_specialty.csv')
print(f"ðŸ“Š Loaded {len(df)} doctor records")
print(f"ðŸ“‹ Columns: {', '.join(df.columns)}")
print("\n" + "="*80)
df.head()

if 'designations' in df.columns:
    df.drop(columns=['designation'], inplace=True)
    print("DataFrame after dropping 'designations' column:")
else:
    print("Column 'designations' not found. It might have been dropped already.")

display(df.head())

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=df)

print('Checking for NaN values in all columns:')
for column in df.columns:
    nan_count = df[column].isnull().sum()
    if nan_count > 0:
        print(f"Column '{column}': {nan_count} NaN values")
    else:
        print(f"Column '{column}': No NaN values")

qualifications_nan_rows = df[df['qualifications'].isnull()]
display(qualifications_nan_rows['profile_url'])

# Update name for index 2842
df.loc[2842, 'name'] = 'Dr. Mir M. Siddiq'

# Update name for index 2906
df.loc[2906, 'name'] = 'Dr. Sofia Rahman'

print("Updated names for specified doctors:")
display(df.loc[[2842, 2906], ['name', 'qualifications']])

# Update qualifications for Dr. Mir M. Siddiq (index 2842)
df.loc[2842, 'qualifications'] = 'MBBS & DD (Bangkok)'

# Update qualifications for Dr. Sofia Rahman (index 2906)
df.loc[2906, 'qualifications'] = 'MBBS & FCPS'

print("Updated qualifications for specified doctors:")
display(df.loc[[2842, 2906], ['name', 'qualifications']])

print(f"Original DataFrame shape: {df.shape}")

# Identify the qualifications starting with 'BMDC' again to ensure consistency
bmdc_qualifications = [q for q in df['qualifications'].unique() if isinstance(q, str) and q.startswith('BMDC')]

# Get the indices of the rows to drop
rows_to_drop_indices = df[df['qualifications'].isin(bmdc_qualifications)].index

# Drop the rows from the DataFrame
df.drop(rows_to_drop_indices, inplace=True)

print(f"DataFrame shape after dropping BMDC profiles: {df.shape}")
display(df.head())

bmdc_qualifications = [q for q in df['qualifications'].unique() if isinstance(q, str) and q.startswith('BMDC')]
bmdc_doctors_profiles = df[df['qualifications'].isin(bmdc_qualifications)]

print("Full profiles of doctors with qualifications starting with 'BMDC':")
display(bmdc_doctors_profiles)

print("Qualifications starting with 'BMDC':")
for q in unique_qualifications:
    if isinstance(q, str) and q.startswith('BMDC'):
        print(q)

specialty_nan_rows = df[df['specialty'].isnull()]
display(specialty_nan_rows)

display(specialty_nan_rows['profile_url'])

pd.set_option('display.max_colwidth', None)
display(specialty_nan_rows['profile_url'])

unique_qualifications = df['qualifications'].unique()
print("Unique values in 'qualifications' column:")
for q in unique_qualifications:
    print(q)

from google.colab import drive
drive.mount('/content/drive')

# Fill NaN values in 'experience' with 1
df['experience'] = df['experience'].fillna('1')

# Extract only the numerical part from 'experience' and convert to integer
df['experience'] = df['experience'].astype(str).str.extract('(\d+)').astype(int)

# Rename the 'experience' column
df.rename(columns={'experience': 'experience(IN YEARS OVERALL)'}, inplace=True)

print("Updated 'experience(IN YEARS OVERALL)' column details:")
display(df[['name', 'experience(IN YEARS OVERALL)']].head())

print('Checking for NaN values in columns (excluding designation):')
for column in df.columns:
    if column != 'designations': # Assuming 'designations' was the column meant, based on head() output
        nan_count = df[column].isnull().sum()
        if nan_count > 0:
            print(f"Column '{column}': {nan_count} NaN values")
        else:
            print(f"Column '{column}': No NaN values")

specialty_nan_rows = df[df['specialty'].isnull()]
display(specialty_nan_rows)

qualifications_nan_rows = df[df['qualifications'].isnull()]
display(qualifications_nan_rows)

df.drop(columns=['designation'], inplace=True)
print("DataFrame after dropping 'designation' column:")
display(df.head())

# Locate the row by index and update the specified columns
df.loc[2906, 'name'] = 'Dr. Sofia Rahman'
df.loc[2906, 'qualifications'] = 'MBBS & FCPS'
df.loc[2906, 'specialty'] = 'Dermatologist'
df.loc[2906, 'experience(IN YEARS OVERALL)'] = 16

print("Updated details for Dr. Sofia Rahman (index 2906):")
display(df.loc[[2906], ['name', 'qualifications', 'specialty', 'experience(IN YEARS OVERALL)']])

"""# Task
Identify and display all rows in the DataFrame `df` that contain repeated values across different columns, ignoring NaN values, and report the total number of such rows found.

## Identify Rows with Repeated Values

### Subtask:
Create a function to check each row for values that are repeated across different columns within that row (ignoring NaN values). This will generate a boolean mask.

**Reasoning**:
To identify rows with repeated values, I will define a function that checks for duplicates in a row while ignoring NaN values, and then apply this function to the DataFrame to create a boolean mask.
"""

def has_repeated_values_in_row(row):
    # Create a copy of the row to avoid modifying the original DataFrame indirectly
    temp_row = row.copy()

    # List of columns to exclude from the repetition check
    excluded_columns = ['designation', 'designations']

    # Drop excluded columns if they exist in the current row's index
    for col in excluded_columns:
        if col in temp_row.index:
            temp_row = temp_row.drop(col)

    non_nan_values = temp_row.dropna()
    return len(non_nan_values) != len(non_nan_values.unique())

repeated_values_mask = df.apply(has_repeated_values_in_row, axis=1)
print(f"Number of rows with repeated values (excluding 'designation' and 'designations'): {repeated_values_mask.sum()}")
display(df[repeated_values_mask].head())

"""**Reasoning**:
The previous step identified the rows with repeated values and displayed the head. To fully address the subtask of displaying 'all' such rows, I will now display the complete DataFrame containing only these identified rows. This will complete the subtask, and I will then mark the subtask as successful.


"""

print("Displaying all rows with repeated values (first 50 rows, excluding 'designation' and 'designations'):")
display(df[repeated_values_mask].head(50))

print(f"DataFrame shape before dropping profiles with repeated values: {df.shape}")

rows_to_drop_repeated_values = df[repeated_values_mask].index
df.drop(rows_to_drop_repeated_values, inplace=True)

print(f"DataFrame shape after dropping profiles with repeated values: {df.shape}")
display(df.head())

"""## Final Task

### Subtask:
Summarize the findings, indicating how many profiles were found with repeated column values in their rows.

## Summary:

### Q&A
*   **How many profiles were found with repeated column values in their rows?**
    There are 44 profiles (rows) in the DataFrame `df` that contain repeated values across different columns, ignoring NaN values.

### Data Analysis Key Findings
*   A custom function, `has_repeated_values_in_row`, was created to identify rows containing repeated values across different columns, while excluding NaN values.
*   The analysis identified a total of 44 rows in the DataFrame `df` that exhibit repeated values within their columns.
*   The rows with repeated values were successfully filtered and displayed.

### Insights or Next Steps
*   The presence of repeated values in 44 profiles suggests potential data entry errors or specific characteristics of the data that might require further investigation to understand their origin and impact.
*   Depending on the context of the data, a next step could involve cleaning these 44 identified rows by either removing the duplicates, correcting the entries, or understanding why these repetitions exist and if they are intentional.
"""



from google.colab import files

# Save the DataFrame to a CSV file
df.to_csv('doctors_data_cleaned.csv', index=False)

# Provide a link to download the file
files.download('doctors_data_cleaned.csv')

print("Your cleaned DataFrame has been saved as 'doctors_data_cleaned.csv' and is ready for download.")

print('Checking for NaN values in columns (excluding designation):')
for column in df.columns:
    if column != 'designations': # Assuming 'designations' was the column meant, based on head() output
        nan_count = df[column].isnull().sum()
        if nan_count > 0:
            print(f"Column '{column}': {nan_count} NaN values")
        else:
            print(f"Column '{column}': No NaN values")